# Develope, test and deploy a smart contract

## Development

### Preparation

- Install dotnet sdk.
  - Follow this doc https://dotnet.microsoft.com/en-us/download to install dotnet sdk. You can choose the 6.x or 7.x version.
  - Type ```dotnet --version```, if return the version of dotnet sdk, the installation is successful.

- Install node.
  - Follow this doc https://nodejs.org/en/download to install node and npm.
  - Type ```node -v``` and ```npm -v```, if return the versions, the installation is successful.


### Create new project

- Open a terminal and type the following command. You can install the contract template from nuget repo to your local.

```
 $ PROD: dotnet new install AElf.HelloWorld.Contract
 $ DEV: dotnet new install AElf.HelloWorld.Contract --nuget-source http://10.0.1.239:8081/repository/nuget-group/index.json
```

- Type the following command, and create a new template project locally. You can modify custom parameters of command to define contract names and namespace. ```-n``` stands for contract name, ```-N``` stands for namespace.

```
$ dotnet new helloworldcontract -n HelloWorld -N AElf.Contracts.HelloWorld
```

For example, ```-n HelloWorld``` means your contract name will be HelloWorld, ```-N AElf.Contracts.HelloWorld``` means your contract namespace will be AElf.Contracts.HelloWorld.
Type the following command to understand usage of all the custom parameters.

```
$ dotnet new helloworldcontract --help
```

### Create or modify project files

- Create new proto files and modify existed project files according to your requirements. 

### Build

- Run the following command and check the result. If have any errors, solve them according to error messages.

```
$ cd src
$ dotnet build
```

## Testing

### Copy proto files (if you created or did some changes on proto files)

- With the same method as above, copy proto files from src folder to base, message, stub folders. And update the import path.

### Create and modify class files

- Create new class files and modify existing class files according to your requirements.

### Build and run

- Run the following command and check the result. If have any errors, solve them according to error messages.

```
$ cd test
$ dotnet build
```

- After building successfully, run ```dotnet test``` command. And check the result. If have any errors, solve them according to error messages.

## RNG (Random number generator) Introduction
RNG is a very important part in AElf porject, AElf currently employs the Verifiable Random Function (VRF) algorithm as its underlying mechanism for generating random numbers. The essence of the VRF algorithm is rooted in mathematical operations on elliptic curves. 
Within VRF, the central algorithm involves the following key steps:

1. Hash to Curve: Transforming input data into a point on an elliptic curve using a hash function. This pivotal step maps input of arbitrary length onto a point on the elliptic curve.

2. Scalar Multiplication: Conducting multiplication operations between points and scalars on the elliptic curve. This operation transforms one point into another through scalar multiples.

3. Nonce Generation: Generating a random number for signing, ensuring uniqueness and unpredictability for each signing instance.

4. Hashing and Concatenation: Hashing and concatenating multiple points to create a new hash value. This step is utilized to generate the final signature or proof.

In the VRF algorithm, these core steps collaborate to generate a verifiable random function value, also referred to as the VRF output. Simultaneously, this process guarantees that other users can verify the authenticity of this output. The accuracy and security of the core algorithm hinge on the mathematical properties of elliptic curves, encompassing operations such as point addition, multiplication, and the characteristics of hash functions.

The following section contains the code of the core algorithm for AElf's VRF along with comments:
```
// Hash input data onto the elliptic curve and attempt multiple hash iterations until a suitable result is found
public IECPoint HashToCurveTryAndIncrement(IECPoint point, byte[] alpha)
{
    using var curve = new TCurve();

    // Step 1: Initialize counter ctr = 0
    var ctr = 0;

    // Step 2: Serialize the input elliptic curve point Y into a string PK_string
    var pkString = curve.SerializePoint(point, true);

    // Steps 3 ~ 6: Attempt multiple hash iterations, incrementing counter ctr, until a suitable result is found or the maximum attempt limit 256 is reached
    byte oneString = 0x01;
    for (; ctr < 256; ctr++)
    {
        using var hasher = _hasherFactory.Create();
        using var stream = new MemoryStream();

        // Step 3: Construct input data for hashing
        stream.WriteByte(_config.SuiteString); // Use SuiteString
        stream.WriteByte(oneString); // Fixed byte 0x01
        stream.Write(pkString); // Add elliptic curve point PK_string
        stream.Write(alpha); // Add input data alpha
        stream.WriteByte((byte)ctr); // Add counter ctr

        // Step 4: Reset stream pointer to the beginning for hashing calculation
        stream.Seek(0, SeekOrigin.Begin);

        // Step 5: Calculate hash value of input data
        var hash = hasher.ComputeHash(stream);

        // Step 6: Parse the hash value into a point on the elliptic curve and attempt to validate its validity
        var pkSerialized = new byte[Secp256k1.SERIALIZED_COMPRESSED_PUBKEY_LENGTH];
        pkSerialized[0] = 0x02;
        Buffer.BlockCopy(hash, 0, pkSerialized, 1, hash.Length);
        try
        {
            var outputPoint = curve.DeserializePoint(pkSerialized);

            // If the elliptic curve parameters include a cofactor, an additional multiplication by the cofactor is necessary to get the final result
            if (_config.EcParameters.Curve.Cofactor.CompareTo(BigInteger.One) > 0)
            {
                return curve.MultiplyScalar(outputPoint,
                    curve.DeserializeScalar(_config.EcParameters.Curve.Cofactor.ToByteArray()));
            }

            // Return the obtained elliptic curve point
            return outputPoint;
        }
        catch (InvalidSerializedPublicKeyException ex)
        {
            // When an exception occurs while parsing the hash value into an elliptic curve point, ignore the exception and continue with the next counter value
        }
    }

    // If a suitable result is not found even after reaching the maximum attempt limit, throw an exception
    throw new FailedToHashToCurveException();
}
```
Code source: https://github.com/AElfProject/AElf/blob/dev/src/AElf.Cryptography/ECVRF/Vrf.cs

In AElf, we have already implemented a wrapper for the VRF algorithm, allowing direct invocation of the `GetRandomHash` function from the `ConsensusContract` at the upper layers to obtain a random number.
```
var randomHash = State.ConsensusContract.GetRandomHash.Call(new Int64Value
{
    Value = targetHeight
});
```
This random number can be verified by anyone possessing a public key, thanks to the characteristics of the VRF: for a given input (commonly referred to as seed or alpha), the same private key always generates the same VRF output. Therefore, the generated proof is unique. Individuals with the public key can use the original input, VRF output, and VRF proof together for validation to confirm that the VRF output indeed originates from that specific input and private key.

## RNG Implementation in AElf

There are many implementations of RNG in AElf projects, we choose a code block from BingoGame to do the demostration:
```
private List<int> GetDices(Hash hashValue)
{
    var hexString = hashValue.ToHex();
    var dices = new List<int>();

    for (int i = 0; i < 3; i++)
    {
        var startIndex = i * 8;
        var intValue = int.Parse(hexString.Substring(startIndex, 8), System.Globalization.NumberStyles.HexNumber);
        var dice = (intValue % 6 + 5) % 6 + 1;
        dices.Add(dice);
    }

    return dices;
}
```
This piece of code takes a `RandomHash` as input, which is the hash obtained under the VRF algorithm, and converts it into a hexadecimal string named `hexString`. Next, it extracts three consecutive groups of eight-bit hexadecimal values from this string and interprets them as integer types. Subsequently, through a series of operations, these three integers are transformed into dice values (integers between 1 and 6). This process enables us to utilize the randomness of the hash value to generate a seemingly random sequence of dice values. This constitutes an instance of a Random Number Generator (RNG).

## RNG Practice
Next, following the example above, we can obtain a `randomHash` to generate a random number. 

Add the following code to the `src/Protobuf/contract/hello_world_contract.proto` file. This line of code will introduce a new method called `Bet`, which takes a string as input and also produces a string as output.

```
  rpc Bet (google.protobuf.StringValue) returns (google.protobuf.StringValue) {
  }
```
And aslo add this line of code into HelloWorldState.cs, this will encapsulates AEDPoS consensus contract reference state.

```
internal AEDPoSContractContainer.AEDPoSContractReferenceState ConsensusContract { get; set; }
```
Add implementation of Bet method in HelloWorld.cs as well:
```
public override StringValue Bet(StringValue input)
{
    var randomHash = State.ConsensusContract.GetRandomHash.Call(new Int64Value
    {
        Value = 8
    });
    var intValue = int.Parse(randomHash.ToHex().Substring(0, 8), System.Globalization.NumberStyles.HexNumber);
    var random = new StringValue();
    if (intValue > 128)
    {
        random.Value = "big";
    } 
    else 
    {
        random.Value = "small";
    }
    var result = new StringValue();

    if (input.Value == random.Value) 
    {
        result.Value = "win";
    } 
    else 
    {
        result.Value = "lose";
    }
    return result;
}
```
The input is the user's guessed size, and random is a randomly generated number. We compare whether the random number is greater than 128 to determine its size. Then we compare the user's guessed size with the random number's size. If they match, it returns "win"; otherwise, it returns "lose".


Next, we need to add a unit test case for the Bet method. We go to the test folder and add this line of code to `test/Protobuf/contract/hello_world_contract.proto`.
```
rpc Bet (google.protobuf.StringValue) returns (google.protobuf.StringValue) {
  }
```
Then add unit test for Bet method in HelloWorldTests.cs:
```
[Fact]
public async Task Bet_Test()
{
    // Arrange
    var input = new StringValue {Value = "big"};
    var result = await HelloWorldStub.Bet.SendAsync(input);
    result.Value.ShouldBe("win");
}
```
## Call the contract

- Send aelf commands.
  - Open terminal, type aelf-command send, fill in the node with http://127.0.0.1:8000, address and password are same as before. Fill the contract with address that return before.
```
$ aelf-command send -a W1ptWN5n5mfdVvh3khTRm9KMJCAUdge9txNyVtyvZaYRYcqc1 {contract_address} -e http://127.0.0.1:8000
```
- Select the interface and type parameters.
  - Select method/interface that you want to test. Type the parameters.
- Check result.
  - If call succeeds. You can get the transactionId.
  - Type http://localhost:8000/swagger/index.html and go to the api/blockChain/transactionResult, fill with the transactionId and click Execute. Get the result and check it.
