# Develope, test and deploy a smart contract

## Development

### Preparation

- Install dotnet sdk.
  - Follow this doc https://dotnet.microsoft.com/en-us/download to install dotnet sdk. You can choose the 6.x or 7.x version.
  - Type ```dotnet --version```, if return the version of dotnet sdk, the installation is successful.

- Install node.
  - Follow this doc https://nodejs.org/en/download to install node and npm.
  - Type ```node -v``` and ```npm -v```, if return the versions, the installation is successful.


### Create new project

- Open a terminal and type the following command. You can install the contract template from nuget repo to your local.

```
 $ PROD: dotnet new install AElf.Contract
 $ DEV: dotnet new install AElf.Contract --nuget-source http://10.0.1.239:8081/repository/nuget-group/index.json
```

- Type the following command, and create a new template project locally. You can modify custom parameters of command to define contract names and namespace. ```-n``` stands for contract name, ```-N``` stands for namespace.

```
$ dotnet new aelfcontract -n HelloWorld -N AElf.Contract
```

For example, ```-n HelloWorld``` means your contract name will be HelloWorld, ```-N AElf.Contracts.HelloWorld``` means your contract namespace will be AElf.Contracts.HelloWorld.
Type the following command to understand usage of all the custom parameters.

```
$ dotnet new aelfcontract --help
```

### High level scope of the project
If you open your project folder, you should see two newly generated directories: src and test. These correspond to the smart contract code and the unit test code for the contract, respectively. The src folder contains several proto files used to describe blockchain smart contract services and data structures. It also includes specific implementations of smart contract methods and definition files for managing contract state in communication with the blockchain, such as HelloWorldState.cs here. 

```
- src
  - Protobuf
  - AElf.Contracts.HelloWorld.csproj
  - HelloWorld.cs
  - HelloWorldState.cs
```

The test folder similarly contains a proto subfolder, along with a setup file used to establish the unit testing environment for blockchain smart contracts. It defines test module classes and a base test class, facilitating context loading, stub class retrieval, and stub acquisition methods. As a result, these classes and methods are employed in unit tests to conduct various tests on the smart contract.

```
- test
  - Protobuf
  - _Setup.cs
  - AElf.Contracts.HelloWorld.Tests.csproj
  - HelloWorldTests.cs
```

In the process of writing smart contracts using AElf tools, the recommended approach involves modifying or creating proto files first. Subsequently, the methods defined in the proto files should be implemented, followed by the addition of unit tests and their execution to verify if these tests pass.

```
Protos -> implementation -> unit test cases
```

### Create or modify project files

- Create new proto files and modify existed project files according to your requirements. 

### Build

- Run the following command and check the result. If have any errors, solve them according to error messages.

```
$ cd src
$ dotnet build
```

## Testing

### Copy proto files (if you created or did some changes on proto files)

- With the same method as above, copy proto files from src folder to base, message, stub folders. And update the import path.

### Create and modify class files

- Create new class files and modify existing class files according to your requirements.

### Build and run

- Run the following command and check the result. If have any errors, solve them according to error messages.

```
$ cd test
$ dotnet build
```

- After building successfully, run ```dotnet test``` command. And check the result. If have any errors, solve them according to error messages.

## RNG (Random number generator) Introduction
RNG is a very important part in AElf porject, AElf currently employs the Verifiable Random Function (VRF) algorithm as its underlying mechanism for generating random numbers. The essence of the VRF algorithm is rooted in mathematical operations on elliptic curves. 

The following section contains the code of the core algorithm for AElf's VRF along with comments to explain each part of code:
```
// Hash input data onto the elliptic curve and attempt multiple hash iterations until a suitable result is found
public IECPoint HashToCurveTryAndIncrement(IECPoint point, byte[] alpha)
{
    using var curve = new TCurve();

    // Step 1: Initialize counter ctr = 0
    var ctr = 0;

    // Step 2: Serialize the input elliptic curve point Y into a string PK_string
    var pkString = curve.SerializePoint(point, true);

    // Steps 3 ~ 6: Attempt multiple hash iterations, incrementing counter ctr, until a suitable result is found or the maximum attempt limit 256 is reached
    byte oneString = 0x01;
    for (; ctr < 256; ctr++)
    {
        using var hasher = _hasherFactory.Create();
        using var stream = new MemoryStream();

        // Step 3: Construct input data for hashing
        stream.WriteByte(_config.SuiteString); // Use SuiteString
        stream.WriteByte(oneString); // Fixed byte 0x01
        stream.Write(pkString); // Add elliptic curve point PK_string
        stream.Write(alpha); // Add input data alpha
        stream.WriteByte((byte)ctr); // Add counter ctr

        // Step 4: Reset stream pointer to the beginning for hashing calculation
        stream.Seek(0, SeekOrigin.Begin);

        // Step 5: Calculate hash value of input data
        var hash = hasher.ComputeHash(stream);

        // Step 6: Parse the hash value into a point on the elliptic curve and attempt to validate its validity
        var pkSerialized = new byte[Secp256k1.SERIALIZED_COMPRESSED_PUBKEY_LENGTH];
        pkSerialized[0] = 0x02;
        Buffer.BlockCopy(hash, 0, pkSerialized, 1, hash.Length);
        try
        {
            var outputPoint = curve.DeserializePoint(pkSerialized);

            // If the elliptic curve parameters include a cofactor, an additional multiplication by the cofactor is necessary to get the final result
            if (_config.EcParameters.Curve.Cofactor.CompareTo(BigInteger.One) > 0)
            {
                return curve.MultiplyScalar(outputPoint,
                    curve.DeserializeScalar(_config.EcParameters.Curve.Cofactor.ToByteArray()));
            }

            // Return the obtained elliptic curve point
            return outputPoint;
        }
        catch (InvalidSerializedPublicKeyException ex)
        {
            // When an exception occurs while parsing the hash value into an elliptic curve point, ignore the exception and continue with the next counter value
        }
    }

    // If a suitable result is not found even after reaching the maximum attempt limit, throw an exception
    throw new FailedToHashToCurveException();
}
```
Code source: https://github.com/AElfProject/AElf/blob/dev/src/AElf.Cryptography/ECVRF/Vrf.cs

In AElf, we have already implemented a wrapper for the VRF algorithm, allowing direct invocation of the `GetRandomHash` function from the `ConsensusContract` at the upper layers to obtain a random number.
```
var randomHash = State.ConsensusContract.GetRandomHash.Call(new Int64Value
{
    Value = targetHeight
});
```
This random number can be verified by anyone possessing a public key, thanks to the characteristics of the VRF: for a given input (commonly referred to as seed or alpha), the same private key always generates the same VRF output. Therefore, the generated proof is unique. Individuals with the public key can use the original input, VRF output, and VRF proof together for validation to confirm that the VRF output indeed originates from that specific input and private key.

## RNG Implementation in AElf

There are many implementations of RNG in AElf projects, we choose a code block from BingoGame to do the demostration:
```
private List<int> GetDices(Hash hashValue)
{
    var hexString = hashValue.ToHex();
    var dices = new List<int>();

    for (int i = 0; i < 3; i++)
    {
        var startIndex = i * 8;
        var intValue = int.Parse(hexString.Substring(startIndex, 8), System.Globalization.NumberStyles.HexNumber);
        var dice = (intValue % 6 + 5) % 6 + 1;
        dices.Add(dice);
    }

    return dices;
}
```
This piece of code takes a `RandomHash` as input, which is the hash obtained under the VRF algorithm, and converts it into a hexadecimal string named `hexString`. Next, it extracts three consecutive groups of eight-bit hexadecimal values from this string and interprets them as integer types. Subsequently, through a series of operations, these three integers are transformed into dice values (integers between 1 and 6).

## RNG Practice
Next, we can do a simple practice of RNG on the workshop project we just created. 

Add the following code to the `src/Protobuf/contract/hello_world_contract.proto` file. This line of code will introduce a new method called `RandomCharacter`, which no need input and produces a string as output.

```
rpc RandomCharacter (google.protobuf.Empty) returns (google.protobuf.StringValue) {
  option (aelf.is_view) = true;
}
```
And aslo add this line of code into HelloWorldState.cs, this will encapsulates AEDPoS consensus contract reference state.

```
using AElf.Contracts.Consensus.AEDPoS;
```
```
internal RandomNumberAccessorContractContainer.RandomNumberAccessorContractReferenceState ConsensusContract { get; set; }
```


Add implementation of RandomCharacter method in HelloWorld.cs as well:
```
public override StringValue RandomCharacter(Empty input)
{
    State.ConsensusContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
    var currentHeight = Context.CurrentHeight;
    var randomHash = State.ConsensusContract.GetRandomHash.Call(new Int64Value
    {
        Value = currentHeight
    });
    var attributes = new List<int>();
    for (int i = 0; i < 3; i++)
    {
    var startIndex = i * 8;
    var intValue = int.Parse(randomHash.ToHex().Substring(startIndex, 8), System.Globalization.NumberStyles.HexNumber);
    var attribute = (intValue % 6 + 5) % 6 + 1;
    attributes.Add(attribute);
    }
    var sum = attributes[0] + attributes[1] + attributes[2];
    var health = 30 * attributes[0] / sum;
    var strength = 30 * attributes[1] / sum;
    var speed = 30 * attributes[2] / sum;
    var character = new StringValue();
    character.Value = $"Here is your character, HP is {health}, strength is {strength}, speed is {speed}";
    return character;
}
```
This code generates a random character's attributes based on a random hash obtained from the consensus contract. The hash is divided into three segments, each transformed into an attribute. The attributes determine health, strength, and speed proportions, which sum up to 30. The resulting character's attributes are then formatted into a message and returned, providing details such as HP, strength, and speed.

Add the required import in HelloWorld.cs
```
using System.Collections.Generic;
```

Next, we need to add a unit test case for the Bet method. We go to the test folder and add this line of code to `test/Protobuf/contract/hello_world_contract.proto`.
```
rpc RandomCharacter (google.protobuf.Empty) returns (google.protobuf.StringValue) {
  option (aelf.is_view) = true;
}
```
Then add unit test for RandomCharacter method in HelloWorldTests.cs:
```
[Fact]
public async Task Random_Test()
{
    // Arrange
    var result = await HelloWorldStub.RandomCharacter.CallAsync(new Empty());
    Console.WriteLine(result.Value);
}
```

Add required import in HelloWorldTests.cs as well
```
using System;
```
## Call the contract

- Send aelf commands.
  - Open terminal, type aelf-command send, fill in the node with http://127.0.0.1:8000, address and password are same as before. Fill the contract with address that return before.
```
$ aelf-command send -a W1ptWN5n5mfdVvh3khTRm9KMJCAUdge9txNyVtyvZaYRYcqc1 {contract_address} -e http://127.0.0.1:8000
```
- Select the interface and type parameters.
  - Select method/interface that you want to test. Type the parameters.
- Check result.
  - If call succeeds. You can get the transactionId.
  - Type http://localhost:8000/swagger/index.html and go to the api/blockChain/transactionResult, fill with the transactionId and click Execute. Get the result and check it.
