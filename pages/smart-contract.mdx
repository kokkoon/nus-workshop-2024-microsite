# Develope, test and deploy a smart contract

## Development

### Preparation

- Install dotnet sdk.
  - Follow this doc https://dotnet.microsoft.com/en-us/download to install dotnet sdk. You can choose the 6.x or 7.x version.
  - Type ```dotnet --version```, if return the version of dotnet sdk, the installation is successful.

- Install node.
  - Follow this doc https://nodejs.org/en/download to install node and npm.
  - Type ```node -v``` and ```npm -v```, if return the versions, the installation is successful.


### Create new project

- Open a terminal and type the following command. You can install the contract template from nuget repo to your local.

```
PROD: dotnet new install AElf.Contract
DEV: dotnet new install AElf.Contract --nuget-source http://10.0.1.239:8081/repository/nuget-group/index.json
```

- Type the following command, and create a new template project locally. You can modify custom parameters of command to define contract names and namespace. ```-n``` stands for contract name, ```-N``` stands for namespace.

```
dotnet new aelfcontract -n HelloWorld -N AElf.Contract
```

For example, ```-n HelloWorld``` means your contract name will be HelloWorld, ```-N AElf.Contracts.HelloWorld``` means your contract namespace will be AElf.Contracts.HelloWorld.
Type the following command to understand usage of all the custom parameters.

```
dotnet new aelfcontract --help
```

### High level scope of the project
If you open your project folder, you should see two newly generated directories: src and test. These correspond to the smart contract code and the unit test code for the contract, respectively. The src folder contains several proto files used to describe blockchain smart contract services and data structures. It also includes specific implementations of smart contract methods and definition files for managing contract state in communication with the blockchain, such as HelloWorldState.cs here. 

```
- src
  - Protobuf
  - AElf.Contracts.HelloWorld.csproj
  - HelloWorld.cs
  - HelloWorldState.cs
```

The test folder similarly contains a proto subfolder, along with a setup file used to establish the unit testing environment for blockchain smart contracts. It defines test module classes and a base test class, facilitating context loading, stub class retrieval, and stub acquisition methods. As a result, these classes and methods are employed in unit tests to conduct various tests on the smart contract.

```
- test
  - Protobuf
  - _Setup.cs
  - AElf.Contracts.HelloWorld.Tests.csproj
  - HelloWorldTests.cs
```

In the process of writing smart contracts using AElf tools, the recommended approach involves modifying or creating proto files first. Subsequently, the methods defined in the proto files should be implemented, followed by the addition of unit tests and their execution to verify if these tests pass.

```
Protos -> implementation -> unit test cases
```

### Create or modify project files

- Create new proto files and modify existed project files according to your requirements. 

### Build

- Run the following command and check the result. If have any errors, solve them according to error messages.

```
cd src
dotnet build
```

## Testing

### Copy proto files (if you created or did some changes on proto files)

- With the same method as above, copy proto files from src folder to base, message, stub folders. And update the import path.

### Create and modify class files

- Create new class files and modify existing class files according to your requirements.

### Build and run

- Run the following command and check the result. If have any errors, solve them according to error messages.

```
cd test
dotnet build
```

- After building successfully, run ```dotnet test``` command. And check the result. If have any errors, solve them according to error messages.

## RNG (Random number generator) Introduction
RNG is a very important part in AElf porject, AElf currently employs the Verifiable Random Function (VRF) algorithm as its underlying mechanism for generating random numbers. The essence of the VRF algorithm is rooted in mathematical operations on elliptic curves. 

You can find the source code of AElf VRF here: https://github.com/AElfProject/AElf/blob/dev/src/AElf.Cryptography/ECVRF/Vrf.cs

In AElf, we have already implemented a wrapper for the VRF algorithm, allowing direct invocation of the `GetRandomHash` function from the `ConsensusContract` at the upper layers to obtain a random number.
```
var randomHash = State.ConsensusContract.GetRandomHash.Call(new Int64Value
{
    Value = targetHeight
});
```
This random number can be verified by anyone possessing a public key, thanks to the characteristics of the VRF: for a given input (commonly referred to as seed or alpha), the same private key always generates the same VRF output. Therefore, the generated proof is unique. Individuals with the public key can use the original input, VRF output, and VRF proof together for validation to confirm that the VRF output indeed originates from that specific input and private key.

## RNG Implementation in AElf

There are many implementations of RNG in AElf projects, we choose a code block from BingoGame to do the demostration:
```
private List<int> GetDices(Hash hashValue)
{
    var hexString = hashValue.ToHex();
    var dices = new List<int>();

    for (int i = 0; i < 3; i++)
    {
        var startIndex = i * 8;
        var intValue = int.Parse(hexString.Substring(startIndex, 8), System.Globalization.NumberStyles.HexNumber);
        var dice = (intValue % 6 + 5) % 6 + 1;
        dices.Add(dice);
    }

    return dices;
}
```
This piece of code takes a `RandomHash` as input, which is the hash obtained under the VRF algorithm, and converts it into a hexadecimal string named `hexString`. Next, it extracts three consecutive groups of eight-bit hexadecimal values from this string and interprets them as integer types. Subsequently, through a series of operations, these three integers are transformed into dice values (integers between 1 and 6).

## RNG Practice
Next, we can do a simple practice of RNG on the workshop project we just created. 

Add the following code to the `src/Protobuf/contract/hello_world_contract.proto` file. This line of code will introduce a new method called `RandomCharacter`, which no need input and produces a string as output.
```
  rpc CreateRandomCharacter (google.protobuf.Empty) returns (google.protobuf.Empty) {
  }
```
```
  rpc GetRandomCharacter (google.protobuf.Empty) returns (google.protobuf.StringValue) {
  option (aelf.is_view) = true;
  }
```
And aslo add this line of code into HelloWorldState.cs, this will encapsulates AEDPoS consensus contract reference state.

```
using AElf.Contracts.Consensus.AEDPoS;
```
```
public StringState Character { get; set; }
internal RandomNumberAccessorContractContainer.RandomNumberAccessorContractReferenceState ConsensusContract { get; set; }
```


Add implementation of CreateRandomCharacter and GetRandomCharacter method in HelloWorld.cs as well:
```
public override Empty CreateRandomCharacter(Empty input)
{
    State.ConsensusContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
    var currentHeight = Context.CurrentHeight;
    var randomHash = State.ConsensusContract.GetRandomHash.Call(new Int64Value
    {
        Value = currentHeight
    });
    var attributes = new List<int>();
    for (int i = 0; i < 3; i++)
    {
    var startIndex = i * 8;
    var intValue = int.Parse(randomHash.ToHex().Substring(startIndex, 8), System.Globalization.NumberStyles.HexNumber);
    var attribute = (intValue % 6 + 5) % 6 + 1;
    attributes.Add(attribute);
    }
    var sum = attributes[0] + attributes[1] + attributes[2];
    var health = 30 * attributes[0] / sum;
    var strength = 30 * attributes[1] / sum;
    var speed = 30 * attributes[2] / sum;
    var character = new StringValue();
    character.Value = $"Here is your character, HP is {health}, strength is {strength}, speed is {speed}";
    State.Character.Value = character.Value;
    return new Empty();
}

public override StringValue GetRandomCharacter(Empty input)
{
    var value = State.Character.Value;
    // Return value retrieved
    return new StringValue
    {
        Value = value
    };
}
```
This code generates a random character's attributes based on a random hash obtained from the consensus contract. The hash is divided into three segments, each transformed into an attribute. The attributes determine health, strength, and speed proportions, which sum up to 30. The resulting character's attributes are then formatted into a message and returned, providing details such as HP, strength, and speed.

Add the required import in HelloWorld.cs
```
using System.Collections.Generic;
```

Next, we need to add a unit test case for the Bet method. We go to the test folder and add this line of code to `test/Protobuf/contract/hello_world_contract.proto`.
```
  rpc CreateRandomCharacter (google.protobuf.Empty) returns (google.protobuf.Empty) {
  }
```
```
  rpc GetRandomCharacter (google.protobuf.Empty) returns (google.protobuf.StringValue) {
  option (aelf.is_view) = true;
  }
```
Then add unit test for RandomCharacter method in HelloWorldTests.cs:
```
[Fact]
public async Task Random_Test()
{
    // Arrange
    await HelloWorldStub.CreateRandomCharacter.SendAsync(new Empty());
    var result = await HelloWorldStub.GetRandomCharacter.CallAsync(new Empty());
    Console.WriteLine(result.Value);
}
```

Add required import in HelloWorldTests.cs as well
```
using System;
```
## Call the contract

- Send aelf commands.
  - Open terminal, type aelf-command send, fill in the node with http://127.0.0.1:8000, address and password are same as before. Fill the contract with address that return before.
```
aelf-command call 2LUmicHyH4RXrMjG4beDwuDsiWJESyLkgkwPdGTR8kahRzq5XS -a W1ptWN5n5mfdVvh3khTRm9KMJCAUdge9txNyVtyvZaYRYcqc1 -e http://127.0.0.1:8000
```
```
aelf-command [call|send] [contract-address|contract-name] [params]
-a, --account <account> 
-e, --endpoint <URI>
```
