---
sidebar_position: 2
---

# How do you use state?

## 1. Define a state in aelf contract

Assuming you have created an aelf contract project called **HelloWorld**, the directory structure generated by the template should like:

```bash
.
├── src
│   ├── HelloWorld.cs
│   ├── HelloWorld.csproj
│   ├── HelloWorldState.cs
│   └── Protobuf
│       ├── contract
│       │   └── hello_world_contract.proto
│       └── message
│           └── authority_info.proto
└── test
    ├── HelloWorld.Tests.csproj
    ├── HelloWorldTests.cs
    ├── Protobuf
    │   ├── message
    │   │   └── authority_info.proto
    │   └── stub
    │       └── hello_world_contract.proto
    └── _Setup.cs
```

Just like when you use a relational database, you need to define data tables. The State of aelf needs to be defined in the State file of one contract. It is the **HelloWorldState.cs** file in the above directory structure. When this file was first generated by aelf contract template tool, it looked like this

```csharp
using AElf.Sdk.CSharp.State;

namespace AElf.Contracts.HelloWorld
{
    // The state class is access the blockchain state
    public class HelloWorldState : ContractState
    {
        // A state that holds string value
        public StringState Message { get; set; }
    }
}
```

Defining a State for a contract is divided into two steps:

1. Add a property to the only class inherited from `ContractState` (just like `HelloWorldState`);
2. Ensure that the type of this property inherits from `StateBase` (like `StringState`, `Int64State` and so on).

You can see that we have already defined a State called `Message` for the HelloWorld Contract, and the type of this State is `StringState`, which is actually an alias of `SingletonState<string>`.

In addition to Singleton State, aelf also supports Mapped State. We can create a `MappedState` here:

```csharp
using AElf.Sdk.CSharp.State;

namespace AElf.Contracts.HelloWorld
{
    // The state class is access the blockchain state
    public class HelloWorldState : ContractState
    {
        // A state that holds string value
        public StringState Message { get; set; }

        /// <summary>
        /// Order -> Message
        /// </summary>
        public MappedState<int, string> Messages { get; set; }
    }
}
```

As the name suggests, `SingletonState` can only be used to store a globally unique value, while `MappedState` can be used to store a mapping.

Like the `Messages` state, in the future, we can access the value of the string type by specifying different keys of int type.

`MappedState` can be multi-level:

```csharp
/// <summary>
/// Date -> Order -> Group -> Message
/// </summary>
public MappedState<Google.Protobuf.WellKnownTypes.Timestamp, int, string, string> Messages { get; set; }
```

## 2. Use the state

After completing the definition of States, you can access these States during the implementation of contract methods.

For the HelloWorld Contract above, the contract implementations are located in **HelloWorld.cs** file.

### 2.1. Read

To read the Message state, all you need is this line:

```csharp
var value = State.Message.Value;
```

If the `Message` state has not written a value before, the above statement will return `default(string)` because the type of `Message` is actually `SingletonState<string>`. For a `SingletonState<int>` type state, whose alias is `Int32State`, its default value is 0, which is the value of `default(int)`.

### 2.2. Modify

To assign a value to the State:

```csharp
State.Message.Value = "hello";
```

When a contract method containing the above code is executed through a transaction, the `Message` state will be assigned the value of `hello` in the aelf blockchain. Afterwards, when other transactions' logic access the `State.Message.Value` of this contract, it will result in the value `hello`, unless it is modified again through another transaction.

### 2.3. Delete

However, the deletion only applies to `MappedState`s. You can use the `Remove` method.

```csharp
// public MappedState<int, string> Messages { get; set; }
// Will delete the value with key 1.
State.Messages.Remove(1);
```
