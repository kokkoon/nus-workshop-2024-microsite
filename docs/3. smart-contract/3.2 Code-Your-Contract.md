---
sidebar_position: 2
---

# Code your contract

Depending on your use case, you can modify the states, contract logics and interfaces to incorporate your specific domain code.

:::tip

The code in this example can be cloned from: https://github.com/gldeng/aelf-nus-workshop-2024-example-code/tree/main/contract.

:::

## 1. Edit files

### 1.1. Edit file `src/Protobuf/contract/hello_world_contract.proto` and copy/paste the following:

```protobuf title="src/Protobuf/contract/hello_world_contract.proto" showLineNumbers
syntax = "proto3";

// highlight-next-line
import "aelf/core.proto";
import "aelf/options.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";
// highlight-next-line
import "Protobuf/reference/acs12.proto";
// Define the namespace of this class.
option csharp_namespace = "AElf.Contracts.HelloWorld";

// highlight-start
service HelloWorld {
    // Declare a state class, need to create a corresponding state class file.
    option (aelf.csharp_state) = "AElf.Contracts.HelloWorld.HelloWorldState";
    option (aelf.base) = "Protobuf/reference/acs12.proto";

    // Actions
    // Define methods name and input/output.
    rpc Initialize (google.protobuf.Empty) returns (google.protobuf.Empty);
    rpc CreateCharacter (google.protobuf.Empty) returns (Character);

    // Views
    rpc GetMyCharacter (aelf.Address) returns (Character) {
        option (aelf.is_view) = true;
    }
}

message Character {
    int32 health = 1;
    int32 strength = 2;
    int32 speed = 3;
}
// highlight-end
```

### 1.2. Edit file `src/HelloWorldState.cs` and copy/paste the following:

```csharp title="src/HelloWorldState.cs" showLineNumbers
// highlight-next-line
using System.Diagnostics.CodeAnalysis;
using AElf.Sdk.CSharp.State;

// highlight-start
using AElf.Standards.ACS6;
using AElf.Types;
// highlight-end

// highlight-start
namespace AElf.Contracts.HelloWorld
{
    // The state class is used to communicate with the blockchain.
    public class HelloWorldState : ContractState
    {
        //create a storage space for Character
        public BoolState Initialized { get; set; }
        public MappedState<Address, Character> Characters { get; set; }

        //encapsulate AEDPoS consensus contract reference state
        internal RandomNumberProvideacsrContractContainer.RandomNumberProvideacsrContractReferenceState
            RandomNumberContract { get; set; }
    }
}
// highlight-end
```

### 1.3. Edit file `src/HelloWorld.cs` and copy/paste the following:

```csharp title="src/HelloWorld.cs" showLineNumbers
using AElf.Sdk.CSharp;
// highlight-next-line
using AElf.Types;
using Google.Protobuf.WellKnownTypes;

// highlight-start
namespace AElf.Contracts.HelloWorld
{
    // Contract class must inherit the class generated by the proto file
    public class HelloWorld : HelloWorldContainer.HelloWorldBase
    {
        // adding this line is for preparing the contract deployment later,
        // to differentiate each person's contract.
        // This is because our testnet does not allow the deployment of two identical contracts.
        const string author = "your name";

        public override Empty Initialize(Empty input)
        {
            Assert(!State.Initialized.Value, "already initialized");
            State.RandomNumberContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
            return new Empty();
        }

        public override Character CreateCharacter(Empty input)
        {
            var randomBytes = State.RandomNumberContract.GetRandomBytes
                .Call(new Int64Value { Value = Context.CurrentHeight - 1 }.ToBytesValue()).Value.ToByteArray();
            var hash = HashHelper.ComputeFrom(Context.Sender).Value.ToByteArray();

            var character = new Character
            {
                Health = 60 + (randomBytes[2] ^ hash[2]) % 41, // Health is 60 ~ 100
                Strength = 40 + (randomBytes[3] ^ hash[3]) % 61, // Strength is 40 ~ 100
                Speed = 100 + (randomBytes[4] ^ hash[4]) % 101 // Speed is 100 ~ 200
            };
            State.Characters[Context.Sender] = character;
            return character;
        }

        public override Character GetMyCharacter(Address input)
        {
            return State.Characters[input] ?? new Character();
        }
    }
}
// highlight-end
```

## 2. Add files

### 2.1. Create a new file `src/Protobuf/base/acs1.proto` and copy/paste the following:

:::tip

For more information on ACS1, refer to https://docs.aelf.io/en/latest/reference/acs/acs1.html

:::

```protobuf title="src/Protobuf/base/acs1.proto" showLineNumbers
/**
 * AElf Standards ACS1(Transaction Fee Standard)
 *
 * Used to manage the transaction fee.
 */
syntax = "proto3";

package acs1;

import public "aelf/options.proto";
import public "google/protobuf/empty.proto";
import public "google/protobuf/wrappers.proto";
import "aelf/core.proto";
import "Protobuf/message/authority_info.proto";

option (aelf.identity) = "acs1";
option csharp_namespace = "AElf.Standards.ACS1";

service MethodFeeProviderContract {

    // Set the method fees for the specified method. Note that this will override all fees of the method.
    rpc SetMethodFee (MethodFees) returns (google.protobuf.Empty) {
    }

    // Change the method fee controller, the default is parliament and default organization.
    rpc ChangeMethodFeeController (AuthorityInfo) returns (google.protobuf.Empty) {
    }

    // Query method fee information by method name.
    rpc GetMethodFee (google.protobuf.StringValue) returns (MethodFees) {
        option (aelf.is_view) = true;
    }

    // Query the method fee controller.
    rpc GetMethodFeeController (google.protobuf.Empty) returns (AuthorityInfo) {
        option (aelf.is_view) = true;
    }
}

message MethodFees {
    // The name of the method to be charged.
    string method_name = 1;
    // List of fees to be charged.
    repeated MethodFee fees = 2;
    bool is_size_fee_free = 3;// Optional based on the implementation of SetMethodFee method.
}

message MethodFee {
    // The token symbol of the method fee.
    string symbol = 1;
    // The amount of fees to be charged.
    int64 basic_fee = 2;
}
```

### 2.2. Create a new file `src/Protobuf/reference/acs6.proto` and copy/paste the following:

:::tip

For more information on ACS6, refer to https://docs.aelf.io/en/latest/reference/acs/acs6.html

:::

```protobuf title="src/Protobuf/reference/acs6.proto" showLineNumbers
syntax = "proto3";

package acs6;

import "aelf/options.proto";
import "aelf/core.proto";
import "google/protobuf/wrappers.proto";

option (aelf.identity) = "acs6";
option csharp_namespace = "AElf.Standards.ACS6";

service RandomNumberProvideacsrContract {
    rpc GetRandomBytes (google.protobuf.BytesValue) returns (google.protobuf.BytesValue) {
        option (aelf.is_view) = true;
    }
}

// Events

message RandomBytesGenerated {
    option (aelf.is_event) = true;
    bytes argument = 1;
    bytes random_bytes = 2;
}
```

### 2.3. Create a new file `src/Protobuf/reference/acs12.proto` and copy/paste the following:

:::tip

For more information on ACS12, refer to https://docs.aelf.io/en/latest/reference/acs/acs12.html

:::

```protobuf title="src/Protobuf/reference/acs12.proto" showLineNumbers
/**
 * AElf Standards ACS12(User Contract Standard)
 *
 * Used to manage user contract.
 */
syntax = "proto3";

package acs12;

import public "aelf/options.proto";
import public "google/protobuf/empty.proto";
import public "google/protobuf/wrappers.proto";
import "aelf/core.proto";

option (aelf.identity) = "acs12";
option csharp_namespace = "AElf.Standards.ACS12";

service UserContract{

}

//Specified method fee for user contract.
message UserContractMethodFees {
    // List of fees to be charged.
    repeated UserContractMethodFee fees = 2;
    // Optional based on the implementation of SetConfiguration method.
    bool is_size_fee_free = 3;
}

message UserContractMethodFee {
    // The token symbol of the method fee.
    string symbol = 1;
    // The amount of fees to be charged.
    int64 basic_fee = 2;
}
```
