---
title: Basics
sidebar_position: 1
---

# Basics

## 1. What is State

The most common approach for storing and retrieving data is accessing **databases** through permission verification in the world of Web2. These databases are generally deployed on independent private servers. Once the database service is attacked, it will result in data being inaccessible and related services will also be affected.

There are many similarities between Web3's **State** and Web2's database services, such as their ability to access data. In fact, for a DApp (Decentralized Application), its user data is mostly stored in the **State**. Compared to database services, State integrates the characteristics of blockchain itself, which are data immutability and very difficult to attack, but it also sets many restrictions on data manipulation.

At first glance, it may look like State are a replacement for database services in Web3 world, but this is not always true. We do not recommend storing all DApp data in the blockchain's State. Here are a few comparisons to base your decision-making on.

|                          | Web2 Database                                                                                       | Web3 State                                                                                                                    |
| ------------------------ | --------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| Cost                     | Depending on the cloud platform, but generally not too much                                         | High, very data writing requires an amount of method fee (like gas fee)                                                       |
| Read                     | Data is not public, mostly restricted                                                               | Data is public to everyone (unless encrypted)                                                                                 |
| Write                    | Depending on the configurations                                                                     | Hard coding in smart contracts implementation                                                                                 |
| Can the data be modified | Yes. For example, modifying data through UPDATE statements. And modification records can be masked. | Yes. Every State can be modified via executing transactions. And every transaction that modifies data is publicly searchable. |
| Data modification logic  | Server side or database stored procedures.                                                          | Can be presented through smart contract, which is publicly transparent.                                                       |
| Revertable               | Easy to revert                                                                                      | Unlikely, the past records are ensured by the blockchain consensus mechanism                                                  |

Overall, blockchain is like a State Machine, and the State is like a database running on blockchain, with data storage specifications created by **smart contracts** where values can only be modified through **transactions**. The transaction is executed under witness of blockchain consensus, which provides transparency for the modification records of data in the State.

Perhaps you would agree with this statement: Writing a smart contract is the process of writing logic for manipulating the data stored in the State.

## 2. How do you use state?

### 2.1. Define a state in aelf contract

Assuming you have created an aelf contract project called **HelloWorld**, the directory structure generated by the template should like:

```bash
.
├── src
│   ├── HelloWorld.cs
│   ├── HelloWorld.csproj
│   ├── HelloWorldState.cs
│   └── Protobuf
│       ├── contract
│       │   └── hello_world_contract.proto
│       └── message
│           └── authority_info.proto
└── test
    ├── HelloWorld.Tests.csproj
    ├── HelloWorldTests.cs
    ├── Protobuf
    │   ├── message
    │   │   └── authority_info.proto
    │   └── stub
    │       └── hello_world_contract.proto
    └── _Setup.cs
```

Just like when you use a relational database, you need to define data tables. The State of aelf needs to be defined in the State file of one contract. It is the **HelloWorldState.cs** file in the above directory structure. When this file was first generated by aelf contract template tool, it looked like this

```csharp
using AElf.Sdk.CSharp.State;

namespace AElf.Contracts.HelloWorld
{
    // The state class is access the blockchain state
    public class HelloWorldState : ContractState
    {
        // A state that holds string value
        public StringState Message { get; set; }
    }
}
```

Defining a State for a contract is divided into two steps:

1. Add a property to the only class inherited from `ContractState` (just like `HelloWorldState`);
2. Ensure that the type of this property inherits from `StateBase` (like `StringState`, `Int64State` and so on).

You can see that we have already defined a State called `Message` for the HelloWorld Contract, and the type of this State is `StringState`, which is actually an alias of `SingletonState<string>`.

In addition to Singleton State, aelf also supports Mapped State. We can create a `MappedState` here:

```csharp
using AElf.Sdk.CSharp.State;

namespace AElf.Contracts.HelloWorld
{
    // The state class is access the blockchain state
    public class HelloWorldState : ContractState
    {
        // A state that holds string value
        public StringState Message { get; set; }

        /// <summary>
        /// Order -> Message
        /// </summary>
        public MappedState<int, string> Messages { get; set; }
    }
}
```

As the name suggests, `SingletonState` can only be used to store a globally unique value, while `MappedState` can be used to store a mapping.

Like the `Messages` state, in the future, we can access the value of the string type by specifying different keys of int type.

`MappedState` can be multi-level:

```csharp
/// <summary>
/// Date -> Order -> Group -> Message
/// </summary>
public MappedState<Google.Protobuf.WellKnownTypes.Timestamp, int, string, string> Messages { get; set; }
```

### 2.2. Use the state

After completing the definition of States, you can access these States during the implementation of contract methods.

For the HelloWorld Contract above, the contract implementations are located in **HelloWorld.cs** file.

To read the Message state, all you need is this line:

```csharp
var value = State.Message.Value;
```

If the `Message` state has not written a value before, the above statement will return `default(string)` because the type of `Message` is actually `SingletonState<string>`. For a `SingletonState<int>` type state, whose alias is `Int32State`, its default value is 0, which is the value of `default(int)`.

To assign a value to the State:

```csharp
State.Message.Value = "hello";
```

When a contract method containing the above code is executed through a transaction, the `Message` state will be assigned the value of `hello` in the aelf blockchain. Afterwards, when other transactions' logic access the `State.Message.Value` of this contract, it will result in the value `hello`, unless it is modified again through another transaction.

### 2.3. Contract State vs. Chain State

The previous discussion was only about Contract States, which can be defined and used by developers themselves in the contract.

In the process of writing the aelf contract, it is very likely that the State on the aelf blockchain will also be needed. These states may arise from consensus and cross-chain mechanisms, or from the System Contract of aelf.

These Chain States can be accessed in contract implementation through `Context`. Of course, these states are **read-only**.

| Chain State                 | Usage                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Context.ChainId             | Get current chain id.                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Context.CurrentHeight       | Get the block height when executing current transaction.                                                                                                                                                                                                                                                                                                                                                                                               |
| Context.CurrentBlockTime    | Get the block time when executing current transaction.                                                                                                                                                                                                                                                                                                                                                                                                 |
| Context.Self                | Get the address of current contract.                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Context.Sender              | Get the sender address of executing transaction.                                                                                                                                                                                                                                                                                                                                                                                                       |
| Context.Origin              | Get the address of original transaction signer.                                                                                                                                                                                                                                                                                                                                                                                                        |
| Context.Transaction         | Get executing transaction.                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Context.PreviousBlockHash   | Get the block hash of previous block.                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Context.TransactionId       | Get the TransactionId of the executing transaction.                                                                                                                                                                                                                                                                                                                                                                                                    |
| Context.OriginTransactionId | Get the TransactionId of the original transaction.                                                                                                                                                                                                                                                                                                                                                                                                     |
| Context.Variables           | Get variables configured during the launching of current chain. For example, on aelf MainChain:<ul><li>`Context.Variables.NativeSymbol` will return `ELF`</li><li>`Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)` will return `{"WRITE","STORAGE","READ","TRAFFIC"}`</li><li>`Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)` will return `{"CPU","RAM","DISK","NET"}`</li></ul> |

## 3. Methods

The contract method not only tells the blockchain how to modify the States defined by this contract, but also includes other outputs. This section will discuss the inputs and outputs related to implementing contract methods.

### 3.1. Inputs

- States of current contract
- States of other contracts
- States of aelf blockchain
- States of parent chain of side chains
- Data from off-chain

### 3.2. Outputs

- Changed states of current contract
- Events fired during the execution of transaction
